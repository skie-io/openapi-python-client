from asyncio import Lock
from threading import RLock
from typing import Any, Dict, Optional

from attrs import define, field
import httpx

from .errors import ClientError, InformationalResponse, RedirectionError, ServerError, NotFoundError
from .json import encode_json
from .jwt import AsyncJWTAuth, SyncJWTAuth


@define
class Client:
    """A class for keeping track of data related to the API

{% macro httpx_args_docstring() %}
    The following are accepted as keyword arguments and will be used to construct httpx Clients internally:

        ``base_url``: The base URL for the API, all requests are made to a relative path to this URL

        ``headers``: A dictionary of headers to be sent with every request

        ``timeout``: The maximum amount of a time a request can take. API functions will raise
        httpx.TimeoutException if this is exceeded.

        ``pool_size``: The maximum number of connections to keep in a connection pool.

        ``httpx_args``: A dictionary of additional arguments to be passed to the ``httpx.Client`` and ``httpx.AsyncClient`` constructor.
{% endmacro %}
{{ httpx_args_docstring() }}

    Attributes:
        raise_for_status: Raise an exception for any responses which are not a 2xx success code.
        key: The private key used to sign the JWT encoded with ES256.
        key_fingerprint: Key ID or fingerprint.
        jwt_expiration: Controls the expiration time for a JWT. 60 seconds by default.
    """
{% macro attributes() %}
    raise_for_status: bool = field(default=True, kw_only=True)
    _base_url: str = field(alias="base_url")
    _headers: Dict[str, str] = field(factory=dict, kw_only=True, alias="headers")
    _timeout: float = field(default=30.0, kw_only=True, alias="timeout")
    _pool_size: int = field(default=10, kw_only=True, alias="pool_size")
    _httpx_args: Dict[str, Any] = field(factory=dict, kw_only=True, alias="httpx_args")
    _client: Optional[httpx.Client] = field(default=None, init=False)
    _async_client: Optional[httpx.AsyncClient] = field(default=None, init=False)
    _lock: RLock = field(init=False)
    _async_lock: Lock = field(init=False)
    _key: str = field(kw_only=True)
    _key_fingerprint: str = field(kw_only=True)
    _jwt_expiration: int = field(default=60, kw_only=True)

    def __attrs_post_init__(self) -> None:
        self._lock = RLock()
        self._async_lock = Lock()

{% endmacro %}{{ attributes() }}
{% macro httpx_stuff(name) %}
    def _init_httpx_client(self) -> httpx.Client:
        auth = SyncJWTAuth(key=self._key, kid=self._key_fingerprint, exp=self._jwt_expiration)

        return httpx.Client(
            auth=auth,
            base_url=self._base_url,
            headers=self._headers,
            timeout=httpx.Timeout(self._timeout, pool=None),
            limits=httpx.Limits(max_connections=self._pool_size, max_keepalive_connections=self._pool_size),
            **self._httpx_args,
        )

    def get_httpx_client(self) -> httpx.Client:
        """Get the underlying httpx.Client, constructing a new one if not previously set"""
        if self._client:
            return self._client

        with self._lock:
            if self._client:
                return self._client

            self._client = self._init_httpx_client()

        return self._client

    def __enter__(self) -> "{{ name }}":
        """Enter a context manager for self.client—you cannot enter twice (see httpx docs)"""
        self.get_httpx_client().__enter__()
        return self

    def __exit__(self, *args: Any, **kwargs: Any) -> None:
        """Exit a context manager for internal httpx.Client (see httpx docs)"""
        self.get_httpx_client().__exit__(*args, **kwargs)

    def _init_async_httpx_client(self) -> httpx.AsyncClient:
        """Get the underlying httpx.AsyncClient, constructing a new one if not previously set"""
        auth = AsyncJWTAuth(key=self._key, kid=self._key_fingerprint, exp=self._jwt_expiration)

        return httpx.AsyncClient(
            auth=auth,
            base_url=self._base_url,
            headers=self._headers,
            timeout=httpx.Timeout(self._timeout, pool=None),
            limits=httpx.Limits(max_connections=self._pool_size, max_keepalive_connections=self._pool_size),
            **self._httpx_args,
        )

    async def get_async_httpx_client(self) -> httpx.AsyncClient:
        if self._async_client:
            return self._async_client

        async with self._async_lock:
            if self._async_client:
                return self._async_client

            self._async_client = self._init_async_httpx_client()

        return self._async_client

    async def __aenter__(self) -> "{{ name }}":
        """Enter a context manager for underlying httpx.AsyncClient—you cannot enter twice (see httpx docs)"""
        client = await self.get_async_httpx_client()
        await client.__aenter__()
        return self

    async def __aexit__(self, *args: Any, **kwargs: Any) -> None:
        """Exit a context manager for underlying httpx.AsyncClient (see httpx docs)"""
        client = await self.get_async_httpx_client()
        await client.__aexit__(*args, **kwargs)

    def request(
        self,
        *,
        method: str,
        url: str,
        data: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None,
        json: Optional[Any] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> httpx.Response:
        if json is not None:
            json = encode_json(json)

        response = self.get_httpx_client().request(
            method=method, url=url, data=data, files=files, content=json, params=params, headers=headers
        )

        if self.raise_for_status:
            self._check_response_status(response)

        return response

    async def async_request(
        self,
        *,
        method: str,
        url: str,
        data: Optional[Dict[str, Any]] = None,
        files: Optional[Dict[str, Any]] = None,
        json: Optional[Any] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> httpx.Response:
        if json is not None:
            json = encode_json(json)

        client = await self.get_async_httpx_client()
        response = await client.request(
            method=method, url=url, data=data, files=files, content=json, params=params, headers=headers
        )

        if self.raise_for_status:
            self._check_response_status(response)

        return response

    def _check_response_status(self, response: httpx.Response) -> None:
        if response.is_success:
            return

        if response.status_code == 404: # noqa: PLR2004
            raise NotFoundError(response)

        if response.is_informational:
            raise InformationalResponse(response)

        if response.is_redirect:
            raise RedirectionError(response)

        if response.is_client_error:
            raise ClientError(response)

        if response.is_server_error:
            raise ServerError(response)
{% endmacro %}{{ httpx_stuff("Client") }}
